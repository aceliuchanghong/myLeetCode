# 输入一个长数组A，以及窗口大小w，输出一个数组B，B[i]代表移动窗口A[i]…A[i+w-1]的最大值。
# 1.判断特殊情况
# 2.算法实现
# 使用一个双端队列（deque）来存储当前窗口的最大值的索引。当你在数组中向右移动窗口时：
# 2.1.从队列的前端移除所有不在当前窗口内的元素的索引。
# 2.2.从队列的后端移除所有小于当前元素值的索引，因为这些元素不可能是当前窗口的最大值。
# 2.3.将当前元素的索引添加到队列的后端。
# 2.4.将队列前端的索引对应的元素（当前窗口的最大值）添加到输出数组B中
from collections import deque


def max_sliding_window(A, w):
    # 1.如果数组为空或者窗口大小为0
    if not A or w == 0:
        return []
    # 初始化双端队列和输出数组
    q = deque()
    B = []
    for i, n in enumerate(A):
        # 移除所有不在当前窗口内的元素的索引,q是索引的队列
        while q and q[0] < i - w + 1:
            q.popleft()
        # 从队列的后端移除所有小于当前元素值的索引
        while q and A[q[-1]] < n:
            q.pop()
        # 将当前元素的索引添加到队列的后端
        q.append(i)
        # 当前窗口形成后开始添加最大值到输出数组
        if i >= w - 1:
            B.append(A[q[0]])
    return B


# 示例使用
A = [1, 3, -1, -3, 5, 3, 6, 7]
w = 3
print(max_sliding_window(A, w))  # 输出应该是 [3, 3, 5, 5, 6, 7]
